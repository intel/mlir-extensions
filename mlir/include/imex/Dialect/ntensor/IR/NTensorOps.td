// Copyright 2022 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef NTENSOR_OPS
#define NTENSOR_OPS

include "mlir/Interfaces/SideEffectInterfaces.td"
include "mlir/IR/AttrTypeBase.td"
include "mlir/IR/BuiltinTypeInterfaces.td"
include "mlir/IR/EnumAttr.td"
include "mlir/IR/OpBase.td"
include "mlir/IR/SubElementInterfaces.td"

def NTensor_Dialect : Dialect {
  let name = "ntensor";
  let cppNamespace = "::imex::ntensor";

  let summary = "Dialect for Numpy-like types and operations.";
  let description = [{
    The `ntensor` dialect consists of 3 groups of operations:
    * High-level ops: `unary`, `binary` and `call`. They are intended to be
    generated by frontends. They support high-level features like named function
    arguments, ommited arguments or `out` tensor arguments.
    * Primitive ops, which are intendend to be lowered to `linalg` or some other
    low level dialect. Primitive ops are guaranteed to have no side effects and
    suitable for common optimizations like CSE and DCE. Any input tensors are
    guaranteed to not be modified and any returned tensors are assumed to be
    freshly allocated and will not alias with any exisiting tensors.
    Currently contains only single `primitive` op, more ops are TBD.
    * Direct tensor access operations: `setitem`, `getitem`.

    All high-level set of ops are intended to be normalised to a limited set of
    primitive ops with named arguments mapped to specific arguments positions,
    ommitted arguments replaced with default values and outpus arguments
    translated to `setitem` calls on tensor.
  }];

  let hasConstantMaterializer = 1;
  let useDefaultTypePrinterParser = 1;
}

class NTensor_Type<string name, string typeMnemonic, list<Trait> traits = [],
                   string baseCppClass = "::mlir::Type">
    : TypeDef<NTensor_Dialect, name, traits, baseCppClass> {
  let mnemonic = typeMnemonic;
}

class NTensor_OpBase<string mnemonic, list<Trait> traits = []>
    : Op<NTensor_Dialect, mnemonic, traits>;

def NTensor_Tensor : NTensor_Type<"NTensor", "ntensor", [
  DeclareTypeInterfaceMethods<SubElementTypeInterface>, ShapedTypeInterface],
  "::imex::ntensor::NTensorBase"> {
  let summary = "Multi-dimensional numpy-like array";
  let description = [{
    Multi-dimensional numpy-like array.

    Contrary to upstream tensor type is has a reference semantics and allow to
    modify data inplace.

    Has optional `environment` attribute, which specifies additional environment
    information for computations on this tensor (e.g. it computation must run on
    specific GPU device).

    TBD
  }];
  let parameters = (ins
    ArrayRefParameter<"int64_t">:$shape,
    "::mlir::Type":$elementType,
    DefaultValuedParameter<"::mlir::Attribute", "">:$environment
  );

  let builders = [
    TypeBuilderWithInferredContext<(ins
      "::llvm::ArrayRef<int64_t>":$shape,
      "::mlir::Type":$elementType,
      CArg<"::mlir::Attribute", "{}">:$environment
    ), [{
      return $_get(elementType.getContext(), shape, elementType, environment);
    }]>
  ];

  let extraClassDeclaration = [{
    using ::mlir::ShapedType::Trait<NTensorType>::clone;
    using ::mlir::ShapedType::Trait<NTensorType>::getElementTypeBitWidth;
    using ::mlir::ShapedType::Trait<NTensorType>::getRank;
    using ::mlir::ShapedType::Trait<NTensorType>::getNumElements;
    using ::mlir::ShapedType::Trait<NTensorType>::isDynamicDim;
    using ::mlir::ShapedType::Trait<NTensorType>::hasStaticShape;
    using ::mlir::ShapedType::Trait<NTensorType>::getNumDynamicDims;
    using ::mlir::ShapedType::Trait<NTensorType>::getDimSize;
    using ::mlir::ShapedType::Trait<NTensorType>::getDynamicDimIndex;
  }];

  let assemblyFormat = "`<` custom<Shape>($shape, $elementType) (`,` $environment^)? `>`";
}

def UnaryOp : NTensor_OpBase<"unary", []> {
  let summary = "Unary operation.";
  let description = [{
    Unary ntesor operation.
  }];

  let arguments = (ins AnyType:$value, StrAttr:$op);

  let results = (outs AnyType:$result);

  let assemblyFormat = "$op ` ` attr-dict `(` $value `:` type($value) `)` `->` type($result)";
}

def BinaryOp : NTensor_OpBase<"binary", []> {
  let summary = "Binary operation.";
  let description = [{
    Binary ntesor operation.
  }];

  let arguments = (ins AnyType:$lhs, AnyType:$rhs, StrAttr:$op);

  let results = (outs AnyType:$result);

  let assemblyFormat = "$op ` ` attr-dict `(` $lhs `:` type($lhs) `,` $rhs `:` type($rhs) `)` `->` type($result)";
}

def SetitemOp : NTensor_OpBase<"setitem", []> {
  let summary = "Array setitem operation.";
  let description = [{
    Ntensor array setitem operation.
  }];

  let arguments = (ins AnyType:$source, AnyType:$index, AnyType:$value);

  let assemblyFormat = "attr-dict `(` $source `:` type($source) `)` `[` $index `:` type($index) `]` `=` `(` $value `:` type($value) `)`";
}

def GetitemOp : NTensor_OpBase<"getitem", [NoSideEffect]> {
  let summary = "Array getitem operation.";
  let description = [{
    Ntensor array getitem operation.
  }];

  let arguments = (ins AnyType:$source, AnyType:$index);

  let results = (outs AnyType:$result);

  let assemblyFormat = "attr-dict `(` $source `:` type($source) `)` `[` $index `:` type($index) `]` `->` type($result)";
}

def CallOp : NTensor_OpBase<"call", []> {
  let summary = "Call operation.";
  let description = [{
    Call operation.

    `args_names` must be array of strings, `args` and `args_names` must have
    same lenght. If `args_names[i]` is non-empty string then `args[i]`
    considered named argument, otherwise it is considered positional.
  }];

  let arguments = (ins Variadic<AnyType>:$args, ArrayAttr:$args_names, StrAttr:$op);

  let results = (outs Variadic<AnyType>:$results);

  let assemblyFormat = "$op ` ` attr-dict custom<ArgList>($args, $args_names) (`:` type($args)^)? (`->` type($results)^)?";
}

def PrimitiveOp : NTensor_OpBase<"primitive", [NoSideEffect]> {
  let summary = "Primitive operation.";
  let description = [{

  }];

  let arguments = (ins Variadic<AnyType>:$args, StrAttr:$op);

  let results = (outs Variadic<AnyType>:$results);

  let assemblyFormat = "$op ` ` attr-dict `(` $args `)` (`:` type($args)^)? (`->` type($results)^)?";
}

#endif // NTENSOR_OPS
