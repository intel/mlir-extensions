// SPDX-FileCopyrightText: 2022 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef NTENSOR_OPS
#define NTENSOR_OPS

include "mlir/Interfaces/CastInterfaces.td"
include "mlir/Interfaces/ControlFlowInterfaces.td"
include "mlir/Interfaces/CopyOpInterface.td"
include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/ShapedOpInterfaces.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
include "mlir/Interfaces/ViewLikeInterface.td"
include "mlir/IR/AttrTypeBase.td"
include "mlir/IR/BuiltinTypeInterfaces.td"
include "mlir/IR/EnumAttr.td"
include "mlir/IR/OpAsmInterface.td"
include "mlir/IR/OpBase.td"
include "mlir/IR/SubElementInterfaces.td"

def NTensor_Dialect : Dialect {
  let name = "ntensor";
  let cppNamespace = "::imex::ntensor";

  let summary = "Dialect for Numpy-like types and operations.";
  let description = [{
    The `ntensor` dialect consists of 3 groups of operations:
    * High-level ops: `unary`, `binary` and `call`. They are intended to be
    generated by frontends. They support high-level features like named function
    arguments, ommited arguments or `out` tensor arguments.
    * Primitive ops, which are intendend to be lowered to `linalg` or some other
    low level dialect. Primitive ops are guaranteed to have no side effects and
    suitable for common optimizations like CSE and DCE. Any input tensors are
    guaranteed to not be modified and any returned tensors are assumed to be
    freshly allocated and will not alias with any exisiting tensors.
    Currently contains only single `primitive` op, more ops are TBD.
    * Direct tensor access operations: `setitem`, `getitem`.

    All high-level set of ops are intended to be normalised to a limited set of
    primitive ops with named arguments mapped to specific arguments positions,
    ommitted arguments replaced with default values and outpus arguments
    translated to `setitem` calls on tensor.
  }];

  let dependentDialects = [
    "::mlir::memref::MemRefDialect",
    "::mlir::tensor::TensorDialect",
    "::mlir::linalg::LinalgDialect"];

  let hasConstantMaterializer = 1;
  let useDefaultTypePrinterParser = 1;
}

class NTensor_Type<string name, string typeMnemonic, list<Trait> traits = [],
                   string baseCppClass = "::mlir::Type">
    : TypeDef<NTensor_Dialect, name, traits, baseCppClass> {
  let mnemonic = typeMnemonic;
}

class NTensor_OpBase<string mnemonic, list<Trait> traits = []>
    : Op<NTensor_Dialect, mnemonic, traits>;

def NTensor_Tensor : NTensor_Type<"NTensor", "ntensor", [
  DeclareTypeInterfaceMethods<SubElementTypeInterface>, ShapedTypeInterface],
  "::imex::ntensor::NTensorBase"> {
  let summary = "Multi-dimensional numpy-like array";
  let description = [{
    Multi-dimensional numpy-like array.

    Contrary to upstream tensor type is has a reference semantics and allow to
    modify data inplace.

    Has optional `environment` attribute, which specifies additional environment
    information for computations on this tensor (e.g. it computation must run on
    specific GPU device).

    TBD
  }];
  let parameters = (ins
    ArrayRefParameter<"int64_t">:$shape,
    "::mlir::Type":$elementType,
    OptionalParameter<"::mlir::Attribute">:$environment,
    OptionalParameter<"::mlir::StringAttr">:$layout
  );

  let builders = [
    TypeBuilderWithInferredContext<(ins
      "::llvm::ArrayRef<int64_t>":$shape,
      "::mlir::Type":$elementType,
      CArg<"::mlir::Attribute", "{}">:$environment,
      CArg<"::llvm::Optional<::llvm::StringRef>", "std::nullopt">:$layout
    ), [{
      auto ctx = elementType.getContext();
      auto l = layout ? ::mlir::StringAttr::get(ctx, *layout) : ::mlir::StringAttr{};
      return $_get(ctx, shape, elementType, environment, l);
    }]>,
    TypeBuilderWithInferredContext<(ins
      "::llvm::ArrayRef<int64_t>":$shape,
      "::mlir::Type":$elementType,
      "::mlir::Attribute":$environment,
      "::mlir::StringAttr":$layout
    ), [{
      auto ctx = elementType.getContext();
      return $_get(ctx, shape, elementType, environment, layout);
    }]>
  ];

  let extraClassDeclaration = [{
    using ::mlir::ShapedType::Trait<NTensorType>::clone;
    using ::mlir::ShapedType::Trait<NTensorType>::getElementTypeBitWidth;
    using ::mlir::ShapedType::Trait<NTensorType>::getRank;
    using ::mlir::ShapedType::Trait<NTensorType>::getNumElements;
    using ::mlir::ShapedType::Trait<NTensorType>::isDynamicDim;
    using ::mlir::ShapedType::Trait<NTensorType>::hasStaticShape;
    using ::mlir::ShapedType::Trait<NTensorType>::getNumDynamicDims;
    using ::mlir::ShapedType::Trait<NTensorType>::getDimSize;
    using ::mlir::ShapedType::Trait<NTensorType>::getDynamicDimIndex;
  }];

  let assemblyFormat = "`<` custom<Shape>($shape, $elementType) (`:` $layout^)? (`,` $environment^)? `>`";
}

def NTensor_Slice : NTensor_Type<"Slice", "slice", [], "::mlir::Type"> {
  let summary = "Slice type for indexing into arrays";
  let description = [{
    TBD
  }];
}

def UnaryOp : NTensor_OpBase<"unary", []> {
  let summary = "Unary operation.";
  let description = [{
    Unary ntesor operation.
  }];

  let arguments = (ins AnyType:$value, StrAttr:$op);

  let results = (outs AnyType:$result);

  let assemblyFormat = "$op ` ` attr-dict `(` $value `:` type($value) `)` `->` type($result)";
}

def BinaryOp : NTensor_OpBase<"binary", []> {
  let summary = "Binary operation.";
  let description = [{
    Binary ntesor operation.
  }];

  let arguments = (ins Arg<AnyType, "", [MemRead]>:$lhs, Arg<AnyType, "", [MemRead]>:$rhs, StrAttr:$op);

  let results = (outs AnyType:$result);

  let assemblyFormat = "$op ` ` attr-dict `(` $lhs `:` type($lhs) `,` $rhs `:` type($rhs) `)` `->` type($result)";
}

def SetitemOp : NTensor_OpBase<"setitem", []> {
  let summary = "Array setitem operation.";
  let description = [{
    Ntensor array setitem operation.
  }];

  let arguments = (ins AnyType:$source, AnyType:$index, AnyType:$value);

  let assemblyFormat = "attr-dict `(` $source `:` type($source) `)` `[` $index `:` type($index) `]` `=` `(` $value `:` type($value) `)`";
}

def GetitemOp : NTensor_OpBase<"getitem", [Pure]> {
  let summary = "Array getitem operation.";
  let description = [{
    Ntensor array getitem operation.
  }];

  let arguments = (ins AnyType:$source, AnyType:$index);

  let results = (outs AnyType:$result);

  let assemblyFormat = "attr-dict `(` $source `:` type($source) `)` `[` $index `:` type($index) `]` `->` type($result)";
}

def CopyOp : NTensor_OpBase<"copy",
    [CopyOpInterface, SameOperandsElementType, SameOperandsShape]> {

  let description = [{
    Copies the data from the source to the destination arrau.

    Source and destination are expected to have the same element type and shape.
    Otherwise, the result is undefined.
  }];

  let arguments = (ins Arg<NTensor_Tensor, "the array to copy from",
                           [MemRead]>:$source,
                       Arg<NTensor_Tensor, "the array to copy to",
                           [MemWrite]>:$target);

  let assemblyFormat = [{
    $source `,` $target attr-dict `:` qualified(type($source)) `to` qualified(type($target))
  }];
}

// Base class for ops with static/dynamic offset, sizes and strides
// attributes/arguments.
class NTensor_OpWithOffsetSizesAndStrides<string mnemonic,
                                          list<Trait> traits = []>
    : NTensor_OpBase<mnemonic, traits> {
  code extraBaseClassDeclaration = [{
    /// Returns the dynamic sizes for this subview operation if specified.
    ::mlir::Operation::operand_range getDynamicSizes() { return getSizes(); }

    /// Return the list of Range (i.e. offset, size, stride). Each
    /// Range entry contains either the dynamic value or a ConstantIndexOp
    /// constructed with `b` at location `loc`.
    ::mlir::SmallVector<::mlir::Range, 8> getOrCreateRanges(
        ::mlir::OpBuilder &b, ::mlir::Location loc) {
      return ::mlir::getOrCreateRanges(*this, b, loc);
    }
  }];
}

def SubviewOp : NTensor_OpWithOffsetSizesAndStrides<"subview", [
    Pure, AttrSizedOperandSegments,
    DeclareOpInterfaceMethods<ReifyRankedShapedTypeOpInterface>,
    OffsetSizeAndStrideOpInterface,
    ViewLikeOpInterface
  ]> {
  let summary = "array subview operation";
  let description = [{
    The "subview" operation converts a array type to another array type
    which represents a reduced-size view of the original array as specified by
    the operation's offsets, sizes and strides arguments.
  }];

  let arguments = (ins
    NTensor_Tensor:$source,
    Variadic<Index>:$offsets,
    Variadic<Index>:$sizes,
    Variadic<Index>:$strides,
    DenseI64ArrayAttr:$static_offsets,
    DenseI64ArrayAttr:$static_sizes,
    DenseI64ArrayAttr:$static_strides
  );
  let results = (outs NTensor_Tensor:$result);

  let assemblyFormat = [{
    $source ``
    custom<DynamicIndexList>($offsets, $static_offsets)
    custom<DynamicIndexList>($sizes, $static_sizes)
    custom<DynamicIndexList>($strides, $static_strides)
    attr-dict `:` qualified(type($source)) `to` qualified(type($result))
  }];

  let builders = [
    // Build a SubViewOp with mixed static and dynamic entries and custom
    // result type. If the type passed is nullptr, it is inferred.
    OpBuilder<(ins
      "::mlir::Value":$source,
      "::mlir::ArrayRef<::mlir::OpFoldResult>":$offsets,
      "::mlir::ArrayRef<::mlir::OpFoldResult>":$sizes,
      "::mlir::ArrayRef<::mlir::OpFoldResult>":$strides,
      CArg<"::mlir::ArrayRef<::mlir::NamedAttribute>", "{}">:$attrs)>,

    // Build a SubViewOp with mixed static and dynamic entries and inferred
    // result type.
    OpBuilder<(ins
      "NTensorType":$resultType,
      "::mlir::Value":$source,
      "::mlir::ArrayRef<::mlir::OpFoldResult>":$offsets,
      "::mlir::ArrayRef<::mlir::OpFoldResult>":$sizes,
      "::mlir::ArrayRef<::mlir::OpFoldResult>":$strides,
      CArg<"::mlir::ArrayRef<::mlir::NamedAttribute>", "{}">:$attrs)>,

    // Build a SubViewOp with static entries and custom result type. If the
    // type passed is nullptr, it is inferred.
    OpBuilder<(ins
      "::mlir::Value":$source,
      "::mlir::ArrayRef<int64_t>":$offsets,
      "::mlir::ArrayRef<int64_t>":$sizes,
      "::mlir::ArrayRef<int64_t>":$strides,
      CArg<"::mlir::ArrayRef<::mlir::NamedAttribute>", "{}">:$attrs)>,

    // Build a SubViewOp with static entries and inferred result type.
    OpBuilder<(ins
      "NTensorType":$resultType,
      "::mlir::Value":$source,
      "::mlir::ArrayRef<int64_t>":$offsets,
      "::mlir::ArrayRef<int64_t>":$sizes,
      "::mlir::ArrayRef<int64_t>":$strides,
      CArg<"::mlir::ArrayRef<::mlir::NamedAttribute>", "{}">:$attrs)>,

    // Build a SubViewOp with dynamic entries and custom result type. If the
    // type passed is nullptr, it is inferred.
    OpBuilder<(ins
      "::mlir::Value":$source,
      "::mlir::ValueRange":$offsets,
      "::mlir::ValueRange":$sizes,
      "::mlir::ValueRange":$strides,
      CArg<"::mlir::ArrayRef<::mlir::NamedAttribute>", "{}">:$attrs)>,

    // Build a SubViewOp with dynamic entries and inferred result type.
    OpBuilder<(ins
      "NTensorType":$resultType,
      "::mlir::Value":$source,
      "::mlir::ValueRange":$offsets,
      "::mlir::ValueRange":$sizes,
      "::mlir::ValueRange":$strides,
      CArg<"::mlir::ArrayRef<::mlir::NamedAttribute>", "{}">:$attrs)>
  ];

  let extraClassDeclaration = extraBaseClassDeclaration # [{
    /// Returns the type of the base tensor operand.
    NTensorType getSourceType() {
      return getSource().getType().cast<NTensorType>();
    }

    /// The result of an extract_slice is always a tensor.
    NTensorType getType() {
      return getResult().getType().cast<NTensorType>();
    }

    /// Compute the rank-reduction mask that can be applied to map the source
    /// tensor type to the result tensor type by dropping unit dims.
    llvm::Optional<llvm::SmallDenseSet<unsigned>>
    computeRankReductionMask() {
      return ::mlir::computeRankReductionMask(getSourceType().getShape(),
                                              getType().getShape());
    };

    /// An extract_slice result type can be inferred, when it is not
    /// rank-reduced, from the source type and the static representation of
    /// offsets, sizes and strides. Special sentinels encode the dynamic case.
    static NTensorType inferResultType(
      NTensorType sourceType,
      ::mlir::ArrayRef<int64_t> staticOffsets,
      ::mlir::ArrayRef<int64_t> staticSizes,
      ::mlir::ArrayRef<int64_t> staticStrides);
    static NTensorType inferResultType(
      NTensorType sourceType,
      ::mlir::ArrayRef<::mlir::OpFoldResult> staticOffsets,
      ::mlir::ArrayRef<::mlir::OpFoldResult> staticSizes,
      ::mlir::ArrayRef<::mlir::OpFoldResult> staticStrides);

    /// A rank-reducing result type can be inferred from the desired result
    /// shape. Only the layout map is inferred.
    ///
    /// Note: The result shape cannot be inferred with just the result rank and
    /// and the desired sizes. In case there are more "ones" among the sizes
    /// than the difference in source/result rank, it is not clear which dims of
    /// size one should be dropped.
    static NTensorType inferRankReducedResultType(::mlir::ArrayRef<int64_t> resultShape,
                                                  NTensorType sourceType,
                                                  ::mlir::ArrayRef<int64_t> staticOffsets,
                                                  ::mlir::ArrayRef<int64_t> staticSizes,
                                                  ::mlir::ArrayRef<int64_t> staticStrides);
    static NTensorType inferRankReducedResultType(::mlir::ArrayRef<int64_t> resultShape,
                                                  NTensorType sourceType,
                                                  ::mlir::ArrayRef<::mlir::OpFoldResult> staticOffsets,
                                                  ::mlir::ArrayRef<::mlir::OpFoldResult> staticSizes,
                                                  ::mlir::ArrayRef<::mlir::OpFoldResult> staticStrides);

    /// Return the expected rank of each of the`static_offsets`, `static_sizes`
    /// and `static_strides` attributes.
    std::array<unsigned, 3> getArrayAttrMaxRanks() {
      unsigned rank = getSourceType().getRank();
      return {rank, rank, rank};
    }

    /// Return the number of leading operands before the `offsets`, `sizes` and
    /// and `strides` operands.
    static unsigned getOffsetSizeAndStrideStartOperandIndex() { return 1; }

    /// Return the dimensions of the source that are dropped in the
    /// result when the result is rank-reduced.
    ::llvm::SmallBitVector getDroppedDims();

    ::mlir::Value getViewSource() { return getSource(); }
  }];
}

def LoadOp : NTensor_OpBase<"load",
     [TypesMatchWith<"result type matches element type of 'array'",
                     "array", "result",
                     "$_self.cast<NTensorType>().getElementType()">]> {
  let summary = "array element load operation";
  let description = [{
    The `load` op reads an element from a array specified by an index list. The
    output of load is a new value with the same type as the elements of the
    array. The arity of indices is the rank of the array (i.e., if the array
    loaded from is of rank 3, then 3 indices are required for the load following
    the array identifier).
  }];

  let arguments = (ins Arg<NTensor_Tensor, "the reference to load from",
                           [MemRead]>:$array,
                       Variadic<Index>:$indices);
  let results = (outs AnyType:$result);

  let builders = [
    OpBuilder<(ins "::mlir::Value":$array, CArg<"::mlir::ValueRange", "{}">:$indices), [{
      auto arrayType = array.getType().cast<NTensorType>();
      $_state.addOperands(array);
      $_state.addOperands(indices);
      $_state.types.push_back(arrayType.getElementType());
    }]>];

  let assemblyFormat = "$array `[` $indices `]` attr-dict `:` qualified(type($array))";

  let hasFolder = 1;
  let hasCanonicalizer = 1;
}

def StoreOp : NTensor_OpBase<"store",
     [TypesMatchWith<"type of 'value' matches element type of 'array'",
                     "array", "value",
                     "$_self.cast<NTensorType>().getElementType()">]> {
  let summary = "array element store operation";
  let description = [{
    Store a value to a array location given by indices. The value stored should
    have the same type as the elemental type of the array. The number of
    arguments provided within brackets need to match the rank of the array.
  }];

  let arguments = (ins AnyType:$value,
                       Arg<NTensor_Tensor, "the reference to store to",
                           [MemWrite]>:$array,
                       Variadic<Index>:$indices);

  let builders = [
    OpBuilder<(ins "::mlir::Value":$valueToStore, "::mlir::Value":$array), [{
      $_state.addOperands(valueToStore);
      $_state.addOperands(array);
    }]>];

  let assemblyFormat = "$value `,` $array `[` $indices `]` attr-dict `:` qualified(type($array))";

  let hasCanonicalizer = 1;
}

def BuildSliceOp : NTensor_OpBase<"build_slice", [
    AttrSizedOperandSegments, Pure]> {
  let summary = "Slice creation operation.";
  let description = [{
    Creates a slice to index into ntensor array.
  }];

  let arguments = (ins Optional<Index>:$begin, Optional<Index>:$end, Optional<Index>:$step);

  let results = (outs NTensor_Slice:$result);

  let assemblyFormat = "attr-dict `(` $begin `:` $end `:` $step `)`";
}

def ResolveSliceOp : NTensor_OpBase<"resolve_slice", [Pure]> {
  let summary = "Slice resolving operation.";
  let description = [{
    Resolves slice using specified size into `begin`, `end` and `step` values.

    Properly handles omitted and negative slice arguments and translates them
    into indices within array bounds.
  }];

  let arguments = (ins NTensor_Slice:$slice, Index:$size);

  let results = (outs Index:$begin, Index:$end, Index:$step, Index:$count);

  let assemblyFormat = "attr-dict $slice `,` $size";

  let hasCanonicalizer = 1;
}

def ResolveIndexOp : NTensor_OpBase<"resolve_index", [Pure]> {
  let summary = "Index resolving operation.";
  let description = [{
    Resolves index into array using specified array size.

    Properly handles negative arguments and translates them into offset within
    array bounds.
  }];

  let arguments = (ins Index:$index, Index:$size);

  let results = (outs Index:$result);

  let assemblyFormat = "attr-dict $index `,` $size";

  let hasCanonicalizer = 1;
}

def DimOp : NTensor_OpBase<"dim", [
    DeclareOpInterfaceMethods<OpAsmOpInterface, ["getAsmResultNames"]>,
    ConditionallySpeculatable, NoMemoryEffect,
    ShapedDimOpInterface]> {
  let summary = "dimension index operation";
  let description = [{
    The `dim` operation takes a array and a dimension operand of type `index`.
    It returns the size of the requested dimension of the given array.
    If the dimension index is out of bounds the behavior is undefined.
  }];

  let arguments = (ins NTensor_Tensor:$source,
                       Index:$index);
  let results = (outs Index:$result);

  let assemblyFormat = [{
    attr-dict $source `,` $index `:` qualified(type($source))
  }];

  let builders = [
    OpBuilder<(ins "::mlir::Value":$source, "int64_t":$index)>,
  ];

  let extraClassDeclaration = [{
    /// Helper function to get the index as a simple integer if it is constant.
    ::llvm::Optional<int64_t> getConstantIndex();

    /// Interface method of ShapedDimOpInterface: Return the source tensor.
    ::mlir::Value getShapedValue() { return getSource(); }

    /// Interface method of ShapedDimOpInterface: Return the dimension.
    ::mlir::OpFoldResult getDimension() { return getIndex(); }

    /// Interface method for ConditionallySpeculatable.
    ::mlir::Speculation::Speculatability getSpeculatability();
  }];

  let hasVerifier = 1;
  let hasFolder = 1;
  let hasCanonicalizer = 1;
}

def CallOp : NTensor_OpBase<"call", []> {
  let summary = "Call operation.";
  let description = [{
    Call operation.

    `args_names` must be array of strings, `args` and `args_names` must have
    same lenght. If `args_names[i]` is non-empty string then `args[i]`
    considered named argument, otherwise it is considered positional.
  }];

  let arguments = (ins Variadic<AnyType>:$args, ArrayAttr:$args_names, StrAttr:$op);

  let results = (outs Variadic<AnyType>:$results);

  let assemblyFormat = "$op ` ` attr-dict custom<ArgList>($args, $args_names) (`:` type($args)^)? (`->` type($results)^)?";
}

def PrimitiveOp : NTensor_OpBase<"primitive", [Pure]> {
  let summary = "Primitive operation.";
  let description = [{

  }];

  let arguments = (ins Variadic<AnyType>:$args, StrAttr:$op);

  let results = (outs Res<Variadic<AnyType>, "", [MemAlloc<DefaultResource>]>:$results);

  let assemblyFormat = "$op ` ` attr-dict `(` $args `)` (`:` type($args)^)? (`->` type($results)^)?";
}

def ViewPrimitiveOp : NTensor_OpBase<"view_primitive", [
    Pure, ViewLikeOpInterface
  ]> {
  let summary = "Primitive operation with view semantics.";
  let description = [{

  }];

  let arguments = (ins
    NTensor_Tensor:$array,
    Variadic<AnyType>:$args,
    StrAttr:$op);

  let results = (outs NTensor_Tensor:$result);

  let assemblyFormat = "$op ` ` attr-dict `(` $array ( `,` $args^)? `)` `:` qualified(type($array)) ( `,` type($args)^)? `->` qualified(type($result))";

  let extraClassDeclaration = [{
      ::mlir::Value getViewSource() { return getArray(); }
  }];
}

def CreateArrayOp : NTensor_OpBase<"create", [AttrSizedOperandSegments, Pure]> {
  let summary = "Array creation operation.";
  let description = [{
    Creates new array from provided shape;

    Follows memref.alloc conventions.

    If `initValue` is provided resulting array wull be initialized with it,
    otherwise it contents is undefined.
  }];

  let arguments = (ins Variadic<Index>:$dynamicSizes, Optional<AnyType>:$initValue);

  let results = (outs Res<NTensor_Tensor, "", [MemAlloc<DefaultResource>]>:$result);

  let assemblyFormat = "`(`$dynamicSizes`)` (`=` `(` $initValue^ `:` type($initValue) `)`)? attr-dict `:` qualified(type($result))";
}

def FromTensorOp : NTensor_OpBase<"from_tensor",
    [Pure, SameOperandsShape, SameOperandsElementType]> {
  let summary = "converts tensor to ntensor array.";
  let description = [{
    Converts from tensor to ntensor array. Shape and element type must match.
  }];

  let arguments = (ins AnyRankedTensor:$tensor);
  let results = (outs Res<NTensor_Tensor, "", [MemAlloc<DefaultResource>]>:$result);

  let assemblyFormat = "$tensor attr-dict `:` type($tensor) `to` qualified(type($result))";

  let hasFolder = 1;
}

def ToTensorOp : NTensor_OpBase<"to_tensor",
    [SameOperandsShape, SameOperandsElementType]> {
  let summary = "converts ntensor array to tensor.";
  let description = [{
    Converts from ntensor array to tensor. Shape and element type must match.
  }];

  let arguments = (ins Arg<NTensor_Tensor,
                       "the reference to load from", [MemRead]>:$array);
  let results = (outs AnyRankedTensor:$result);

  let assemblyFormat = "$array attr-dict `:` qualified(type($array)) `to` type($result)";

  let hasFolder = 1;
}

def FromMemrefOp : NTensor_OpBase<"from_memref",
    [Pure, SameOperandsShape, SameOperandsElementType, ViewLikeOpInterface]> {
  let summary = "converts memref to ntensor array.";
  let description = [{
    Converts from memref to ntensor array. Shape and element type must match.
  }];

  let arguments = (ins AnyMemRef:$memref);
  let results = (outs NTensor_Tensor:$result);

  let assemblyFormat = "$memref attr-dict `:` type($memref) `to` qualified(type($result))";

  let hasFolder = 1;

  let extraClassDeclaration = [{
      ::mlir::Value getViewSource() { return getMemref(); }
  }];
}

def ToMemrefOp : NTensor_OpBase<"to_memref",
    [Pure, SameOperandsShape, SameOperandsElementType, ViewLikeOpInterface]> {
  let summary = "converts ntensor array to memref.";
  let description = [{
    Converts from ntensor array to memref. Shape and element type must match.
  }];

  let arguments = (ins NTensor_Tensor:$array);
  let results = (outs AnyMemRef:$result);

  let assemblyFormat = "$array attr-dict `:` qualified(type($array)) `to` type($result)";

  let hasFolder = 1;

  let extraClassDeclaration = [{
      ::mlir::Value getViewSource() { return getArray(); }
  }];
}

def ElementwiseOp : NTensor_OpBase<"elementwise", [
    SameOperandsShape,
    SingleBlockImplicitTerminator<"::imex::ntensor::ElementwiseYieldOp">,
    Pure]> {
  let summary = "Elementwise operation";
  let description = [{
    TBD
  }];


  let arguments = (ins Arg<Variadic<NTensor_Tensor>, "", [MemRead]>:$inputs);
  let results = (outs Res<Variadic<NTensor_Tensor>, "", [MemAlloc<DefaultResource>]>:$results);

  let regions = (region SizedRegion<1>:$region);

  let assemblyFormat =
      "attr-dict $inputs `:` qualified(type($inputs)) `->` qualified(type($results)) $region";

  let builders = [
    OpBuilder<(ins
      "::mlir::TypeRange":$resultTypes,
      "::mlir::ValueRange":$inputs,
      CArg<"::llvm::function_ref<void(::mlir::OpBuilder &, ::mlir::Location, ::mlir::ValueRange)>">)>
  ];
}

def ElementwiseYieldOp : NTensor_OpBase<"elementwise_yield", [
  Pure,
  ReturnLike,
  Terminator,
  HasParent<"::imex::ntensor::ElementwiseOp">
  ]> {

  let summary = "Elementwise op region yield and termination operation";
  let description = [{
    "elementwise_yield" yields an SSA value from the "elementwise" op region and
    terminates it.
  }];

  let arguments = (ins Variadic<AnyType>:$values);
  let builders = [OpBuilder<(ins), [{ /* nothing to do */ }]>];

  let assemblyFormat = "attr-dict $values `:` type($values)";
}

def CastOp : NTensor_OpBase<"cast", [
    DeclareOpInterfaceMethods<CastOpInterface>,
    ViewLikeOpInterface,
    Pure
  ]> {
  let summary = "Array cast operation";
  let description = [{
    Convert a array from one type to an equivalent type without changing any
    data elements. The source and destination types must both be array types
    with the same element type. The operation is invalid if converting to a
    mismatching constant dimension.
  }];

  let arguments = (ins NTensor_Tensor:$source);
  let results = (outs NTensor_Tensor:$dest);
  let assemblyFormat = "$source attr-dict `:` qualified(type($source)) `to` qualified(type($dest))";

  let extraClassDeclaration = [{
      ::mlir::Value getViewSource() { return getSource(); }
  }];

  let hasFolder = 1;
}

def FromElementsOp : NTensor_OpBase<"from_elements", [
    Pure,
    TypesMatchWith<"operand types match result element type",
               "result", "elements", "::llvm::SmallVector<::mlir::Type, 2>("
               "$_self.cast<::mlir::ShapedType>().getNumElements(), "
               "$_self.cast<::mlir::ShapedType>().getElementType())">
  ]> {
  let summary = "Array from elements operation.";
  let description = [{
    Create a N-D array from a range of same-type arguments. The number of
    provided `elements` should equal to the number of the elements in the
    result type. The `elements` correspond to a flattened array.
  }];

  let arguments = (ins Variadic<AnyType>:$elements);
  let results = (outs Res<NTensor_Tensor, "", [MemAlloc<DefaultResource>]>:$result);

  let assemblyFormat = "$elements attr-dict `:` qualified(type($result))";
}

def BroadcastOp : NTensor_OpBase<"broadcast", [
    Pure, SameVariadicOperandSize]> {
  let summary = "Array broadcast operation";
  let description = [{
    Broadcast multiple arrays according to numpy broadcast rules. Single-array
    input is also allowed and it is no-op.
  }];


  let arguments = (ins Arg<Variadic<NTensor_Tensor>, "", [MemRead]>:$inputs);
  let results = (outs Res<Variadic<NTensor_Tensor>, "", [MemAlloc<DefaultResource>]>:$results);

  let assemblyFormat =
    "attr-dict `(` $inputs `)` `:`  qualified(type($inputs)) `->` qualified(type($results))";

  let hasFolder = 1;
  let hasCanonicalizer = 1;
}


#endif // NTENSOR_OPS
