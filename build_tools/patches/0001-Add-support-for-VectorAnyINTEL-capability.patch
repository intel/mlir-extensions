From 2cea04474a86c5c55996b72af05c411e9eb87dd7 Mon Sep 17 00:00:00 2001
From: Garra1980 <igor.zamyatin@intel.com>
Date: Thu, 12 Feb 2026 22:33:24 +0100
Subject: [PATCH] Add support for VectorAnyINTEL capability

---
 .../mlir/Dialect/SPIRV/IR/SPIRVBase.td        |  19 ++-
 mlir/include/mlir/IR/CommonTypeConstraints.td |  86 +++++++++++
 mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp    |   7 +-
 mlir/lib/Dialect/SPIRV/IR/SPIRVTypes.cpp      |  26 +++-
 .../SPIRV/Transforms/SPIRVConversion.cpp      | 135 +++++++++++++++---
 5 files changed, 241 insertions(+), 32 deletions(-)

diff --git a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td
index 2f189c64300a..983d9e6c4dd1 100644
--- a/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td
+++ b/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td
@@ -4275,7 +4275,20 @@ def SPIRV_Float8E5M2EXT : TypeAlias<F8E5M2, "Float8E5M2">;
 def SPIRV_Float : FloatOfWidths<[16, 32, 64]>;
 def SPIRV_Float16or32 : FloatOfWidths<[16, 32]>;
 def SPIRV_AnyFloat : AnyTypeOf<[SPIRV_Float, SPIRV_BFloat16KHR, SPIRV_Float8E4M3EXT, SPIRV_Float8E5M2EXT]>;
-def SPIRV_Vector : VectorOfRankAndLengthAndType<[1], [2, 3, 4, 8, 16],
+// Vector type is quite restrictive in SPIR-V.
+// It only allows length of 2, 3, and 4 by default and
+// additionally 8, and 16 via vector16 capability.
+// However, Intel SPIR-V extension removes this restriction
+// via VectorAnyINTEL capability (SPV_INTEL_vector_compute extension).
+// It allows vector length of 2 to 2^32-1.
+//
+// NOTE: VectorOfRankAndLengthAndType uses a list of exact lengths, not ranges.
+// The format is [length1, length2, ...] where each value is checked for equality.
+// To support VectorAnyINTEL without implementing range-based constraints,
+// we list common power-of-2 sizes that cover typical use cases.
+// Verification in SPIRVDialect.cpp and SPIRVTypes.cpp enforces the full [2, 2^32-1] range.
+def SPIRV_Vector : VectorOfRankAndLengthAndType<[1],
+                                       [2, 3, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096],
                                        [SPIRV_Bool, SPIRV_Integer, SPIRV_AnyFloat]>;
 // Component type check is done in the type parser for the following SPIR-V
 // dialect-specific types so we use "Any" here.
@@ -4328,7 +4341,9 @@ class SPIRV_MatrixOfType<list<Type> allowedTypes> :
     "Matrix">;

 class SPIRV_VectorOf<Type type> :
-    FixedVectorOfRankAndLengthAndType<[1], [2, 3, 4, 8, 16], [type]>;
+    FixedVectorOfRankAndLengthAndType<[1],
+                                      [2, 3, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096],
+                                      [type]>;

 class SPIRV_ScalarOrVectorOf<Type type> :
     AnyTypeOf<[type, SPIRV_VectorOf<type>]>;
diff --git a/mlir/include/mlir/IR/CommonTypeConstraints.td b/mlir/include/mlir/IR/CommonTypeConstraints.td
index a49880b81e90..b351a23b7b5b 100644
--- a/mlir/include/mlir/IR/CommonTypeConstraints.td
+++ b/mlir/include/mlir/IR/CommonTypeConstraints.td
@@ -718,6 +718,92 @@ class ScalableVectorOfRankAndLengthAndType<list<int> allowedRanks,
   ScalableVectorOfLength<allowedLengths>.summary,
   "::mlir::VectorType">;

+// Whether the number of elements of a vector is from the given
+// `allowedRanges` list, the list has two values, start and end of the range (inclusive)
+class IsVectorOfLengthRangePred<list<int> allowedRanges> :
+  And<[IsVectorOfNonZeroRankTypePred,
+       And<[CPred<[{::llvm::cast<::mlir::VectorType>($_self).getNumElements()
+                           >= }]
+                         # allowedRanges[0]>,
+                        CPred<[{::llvm::cast<::mlir::VectorType>($_self).getNumElements()
+                           <= }]
+                         # allowedRanges[1]>]>]>;
+
+// Whether the number of elements of a fixed-length vector is from the given
+// `allowedRanges` list, the list has two values, start and end of the range (inclusive)
+class IsFixedVectorOfLengthRangePred<list<int> allowedRanges> :
+  And<[IsFixedVectorOfAnyRankTypePred,
+       And<[CPred<[{::llvm::cast<::mlir::VectorType>($_self).getNumElements()
+                           >= }]
+                         # allowedRanges[0]>,
+                        CPred<[{::llvm::cast<::mlir::VectorType>($_self).getNumElements()
+                           <= }]
+                         # allowedRanges[1]>]>]>;
+
+// Whether the number of elements of a scalable vector is from the given
+// `allowedRanges` list, the list has two values, start and end of the range (inclusive)
+class IsScalableVectorOfLengthRangePred<list<int> allowedRanges> :
+  And<[IsVectorTypeWithAnyDimScalablePred,
+       And<[CPred<[{::llvm::cast<::mlir::VectorType>($_self).getNumElements()
+                           >= }]
+                         # allowedRanges[0]>,
+                        CPred<[{::llvm::cast<::mlir::VectorType>($_self).getNumElements()
+                           <= }]
+                         # allowedRanges[1]>]>]>;
+
+// Any vector where the number of elements is from the given
+// `allowedRanges` list
+class VectorOfLengthRange<list<int> allowedRanges> : Type<
+  IsVectorOfLengthRangePred<allowedRanges>,
+  " of length " # !interleave(allowedRanges, "-"),
+  "::mlir::VectorType">;
+
+// Any fixed-length vector where the number of elements is from the given
+// `allowedLengths` list
+class FixedVectorOfLengthRange<list<int> allowedRanges> : Type<
+  IsFixedVectorOfLengthRangePred<allowedRanges>,
+  " of length " # !interleave(allowedRanges, "-"),
+  "::mlir::VectorType">;
+
+// Any scalable vector where the number of elements is from the given
+// `allowedLengths` list
+class ScalableVectorOfLengthRange<list<int> allowedRanges> : Type<
+  IsScalableVectorOfLengthRangePred<allowedRanges>,
+  " of length " # !interleave(allowedRanges, "-"),
+  "::mlir::VectorType">;
+
+// Any vector where the number of elements is from the given
+// `allowedRanges` list and the type is from the given `allowedTypes`
+// list
+class VectorOfLengthRangeAndType<list<int> allowedRanges,
+                            list<Type> allowedTypes> : Type<
+  And<[VectorOfNonZeroRankOf<allowedTypes>.predicate,
+       VectorOfLengthRange<allowedRanges>.predicate]>,
+  VectorOfNonZeroRankOf<allowedTypes>.summary # VectorOfLengthRange<allowedRanges>.summary,
+  "::mlir::VectorType">;
+
+// Any fixed-length vector where the number of elements is from the given
+// `allowedRanges` list and the type is from the given `allowedTypes`
+// list
+class FixedVectorOfLengthRangeAndType<list<int> allowedRanges,
+                                    list<Type> allowedTypes> : Type<
+  And<[FixedVectorOfAnyRank<allowedTypes>.predicate,
+       FixedVectorOfLengthRange<allowedRanges>.predicate]>,
+  FixedVectorOfAnyRank<allowedTypes>.summary #
+  FixedVectorOfLengthRange<allowedRanges>.summary,
+  "::mlir::VectorType">;
+
+// Any scalable vector where the number of elements is from the given
+// `allowedRanges` list and the type is from the given `allowedTypes`
+// list
+class ScalableVectorOfLengthRangeAndType<list<int> allowedRanges,
+                                    list<Type> allowedTypes> : Type<
+  And<[ScalableVectorOfAnyRank<allowedTypes>.predicate,
+       ScalableVectorOfLengthRange<allowedRanges>.predicate]>,
+  ScalableVectorOfAnyRank<allowedTypes>.summary #
+  ScalableVectorOfLengthRange<allowedRanges>.summary,
+  "::mlir::VectorType">;
+
 // Any ShapedType where the size of the n-th dim is contained in `allowedSizes`.
 // Negative values for `n` index in reverse.
 class ShapedTypeWithNthDimOfSize<int n, list<int> allowedSizes> : Type<
diff --git a/mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp b/mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp
index 78f33c238d41..8602b5d81140 100644
--- a/mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp
+++ b/mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp
@@ -190,9 +190,12 @@ static Type parseAndVerifyType(SPIRVDialect const &dialect,
       parser.emitError(typeLoc, "SPIR-V does not allow one-element vectors");
       return Type();
     }
-    if (t.getNumElements() > 4) {
+    // Number of elements should be between [2 to 2^32 - 1] for SPIR-V vector
+    // type.
+    if (t.getNumElements() < 2 ||
+        t.getNumElements() > std::numeric_limits<uint32_t>::max()) {
       parser.emitError(
-          typeLoc, "vector length has to be less than or equal to 4 but found ")
+          typeLoc, "vector length has to be between [2 - 2^32 -1] but found ")
           << t.getNumElements();
       return Type();
     }
diff --git a/mlir/lib/Dialect/SPIRV/IR/SPIRVTypes.cpp b/mlir/lib/Dialect/SPIRV/IR/SPIRVTypes.cpp
index 63b51d1836f7..a31d96d6bbb0 100644
--- a/mlir/lib/Dialect/SPIRV/IR/SPIRVTypes.cpp
+++ b/mlir/lib/Dialect/SPIRV/IR/SPIRVTypes.cpp
@@ -186,9 +186,10 @@ bool CompositeType::classof(Type type) {
 }

 bool CompositeType::isValid(VectorType type) {
-  return type.getRank() == 1 &&
-         llvm::is_contained({2, 3, 4, 8, 16}, type.getNumElements()) &&
-         isa<ScalarType>(type.getElementType());
+  // Number of elements should be between [2 to 2^32 - 1].
+  return type.getRank() == 1 && isa<ScalarType>(type.getElementType()) &&
+         type.getNumElements() >= 2 &&
+         type.getNumElements() <= std::numeric_limits<uint32_t>::max();
 }

 Type CompositeType::getElementType(unsigned index) const {
@@ -217,8 +218,23 @@ void TypeCapabilityVisitor::addConcrete(VectorType type) {

   int64_t vecSize = type.getNumElements();
   if (vecSize == 8 || vecSize == 16) {
-    static constexpr auto cap = Capability::Vector16;
-    capabilities.push_back(cap);
+    static const Capability caps[] = {Capability::Vector16,
+                                      Capability::VectorAnyINTEL};
+    ArrayRef<Capability> ref(caps, std::size(caps));
+    capabilities.push_back(ref);
+  }
+  // If the vector size is between [2 to 2^32 - 1]
+  // and not of any size 2, 3, 4, 8, and 16
+  // VectorAnyIntel Capability must be present
+  // for the SPIR-V to be valid
+  llvm::SmallVector<uint32_t, 5> allowedVecRange = {2, 3, 4, 8, 16};
+  if (vecSize >= 2 &&
+      (llvm::none_of(allowedVecRange, [&](uint32_t allowedVecSize) {
+       return vecSize == allowedVecSize;
+     }))) {
+    static const Capability caps[] = {Capability::VectorAnyINTEL};
+    ArrayRef<Capability> ref(caps, std::size(caps));
+    capabilities.push_back(ref);
   }
 }

diff --git a/mlir/lib/Dialect/SPIRV/Transforms/SPIRVConversion.cpp b/mlir/lib/Dialect/SPIRV/Transforms/SPIRVConversion.cpp
index 973c16e62bb1..51e81ee0a356 100644
--- a/mlir/lib/Dialect/SPIRV/Transforms/SPIRVConversion.cpp
+++ b/mlir/lib/Dialect/SPIRV/Transforms/SPIRVConversion.cpp
@@ -84,9 +84,13 @@ static std::optional<SmallVector<int64_t>> getTargetShape(VectorType vecType) {
 template <typename LabelT>
 static LogicalResult checkExtensionRequirements(
     LabelT label, const spirv::TargetEnv &targetEnv,
-    const spirv::SPIRVType::ExtensionArrayRefVector &candidates) {
+    const spirv::SPIRVType::ExtensionArrayRefVector &candidates,
+    const ArrayRef<spirv::Extension> &elidedCandidates = {}) {
   for (const auto &ors : candidates) {
-    if (targetEnv.allows(ors))
+    if (targetEnv.allows(ors) ||
+        llvm::any_of(elidedCandidates, [&](spirv::Extension elidedExt) {
+          return llvm::is_contained(ors, elidedExt);
+        }))
       continue;

     LLVM_DEBUG({
@@ -112,9 +116,13 @@ static LogicalResult checkExtensionRequirements(
 template <typename LabelT>
 static LogicalResult checkCapabilityRequirements(
     LabelT label, const spirv::TargetEnv &targetEnv,
-    const spirv::SPIRVType::CapabilityArrayRefVector &candidates) {
+    const spirv::SPIRVType::CapabilityArrayRefVector &candidates,
+    const ArrayRef<spirv::Capability> &elidedCandidates = {}) {
   for (const auto &ors : candidates) {
-    if (targetEnv.allows(ors))
+    if (targetEnv.allows(ors) ||
+        llvm::any_of(elidedCandidates, [&](spirv::Capability elidedCap) {
+          return llvm::is_contained(ors, elidedCap);
+        }))
       continue;

     LLVM_DEBUG({
@@ -131,6 +139,55 @@ static LogicalResult checkCapabilityRequirements(
   return success();
 }

+/// Check capabilities and extensions requirements,
+/// this function also checks for capability infered extension requirements,
+/// the check is based on capabilities that are passed to the targetEnv.
+///
+/// It Also provides a way to relax requirements for certain capabilities and
+/// extensions (e.g., elidedCapCandidates, elidedExtCandidates), this is to
+/// allow passes to relax certain requirements based on an option (e.g.,
+/// relaxing bitwidth requirement, see convertScalarType(), ConvertVectorType())
+template <typename LabelT>
+static LogicalResult checkCapabilityAndExtensionRequirements(
+    LabelT label, const spirv::TargetEnv &targetEnv,
+    const spirv::SPIRVType::CapabilityArrayRefVector &capCandidates,
+    const spirv::SPIRVType::ExtensionArrayRefVector &extCandidates,
+    const ArrayRef<spirv::Capability> &elidedCapCandidates = {},
+    const ArrayRef<spirv::Extension> &elidedExtCandidates = {}) {
+  llvm::SmallVector<::llvm::ArrayRef<::mlir::spirv::Extension>, 8>
+      updatedExtCandidates;
+  llvm::copy(extCandidates, updatedExtCandidates.begin());
+  if (failed(checkCapabilityRequirements(label, targetEnv, capCandidates,
+                                         elidedCapCandidates)))
+    return failure();
+  // Add capablity infered extensions to the list of extension requirement list,
+  // only considers the capabilities that already available in the targetEnv
+
+  // @FIXME: Some capabilities are part of both the core SPIR-V specification
+  // and an extension (e.g., 'Groups' capability is part of both core
+  // specification and SPV_AMD_shader_ballot extension, hence we should relax
+  // the capability inferred extension for this cases)
+  static const ::mlir::spirv::Capability multiModalCaps[] = {
+      ::mlir::spirv::Capability::Groups};
+  ArrayRef<::mlir::spirv::Capability> multiModalCapsArrayRef(
+      multiModalCaps, std::size(multiModalCaps));
+
+  for (auto cap : targetEnv.getAttr().getCapabilities()) {
+    if (llvm::any_of(
+            multiModalCapsArrayRef,
+            [&](::mlir::spirv::Capability mMCap) { return cap == mMCap; }))
+      continue;
+    std::optional<::llvm::ArrayRef<::mlir::spirv::Extension>> ext =
+        getExtensions(cap);
+    if (ext.has_value())
+      updatedExtCandidates.push_back(ext.value());
+  }
+  if (failed(checkExtensionRequirements(label, targetEnv, updatedExtCandidates,
+                                        elidedExtCandidates)))
+    return failure();
+  return success();
+}
+
 /// Returns true if the given `storageClass` needs explicit layout when used in
 /// Shader environments.
 static bool needsExplicitLayout(spirv::StorageClass storageClass) {
@@ -284,11 +341,14 @@ convertScalarType(const spirv::TargetEnv &targetEnv,
     return nullptr;
   }

+  //  Convert to 32-bit float and remove floatType related capability
+  //  restriction
   if (auto floatType = dyn_cast<FloatType>(type)) {
     LLVM_DEBUG(llvm::dbgs() << type << " converted to 32-bit for SPIR-V\n");
     return Builder(targetEnv.getContext()).getF32Type();
   }

+  //  Convert to 32-bit int and remove intType related capability restriction
   auto intType = cast<IntegerType>(type);
   LLVM_DEBUG(llvm::dbgs() << type << " converted to 32-bit for SPIR-V\n");
   return IntegerType::get(targetEnv.getContext(), /*width=*/32,
@@ -402,10 +462,13 @@ convertVectorType(const spirv::TargetEnv &targetEnv,

     if (type.getRank() <= 1 && type.getNumElements() == 1)
       return elementType;
-
-    if (type.getNumElements() > 4) {
-      LLVM_DEBUG(llvm::dbgs()
-                 << type << " illegal: > 4-element unimplemented\n");
+    // Number of elements should be between [2 to 2^32 - 1] for SPIR-V vector
+    // type.
+    if (type.getNumElements() < 2 &&
+        type.getNumElements() > std::numeric_limits<uint32_t>::max()) {
+      LLVM_DEBUG(llvm::dbgs() << type
+                              << " illegal: SPIR-V vector length has to be "
+                                 "between [2 - 2^32 -1]\n");
       return nullptr;
     }

@@ -427,16 +490,40 @@ convertVectorType(const spirv::TargetEnv &targetEnv,
   cast<spirv::CompositeType>(type).getExtensions(extensions, storageClass);
   cast<spirv::CompositeType>(type).getCapabilities(capabilities, storageClass);

-  // If all requirements are met, then we can accept this type as-is.
-  if (succeeded(checkCapabilityRequirements(type, targetEnv, capabilities)) &&
-      succeeded(checkExtensionRequirements(type, targetEnv, extensions)))
-    return type;
-
+  // If the bit-width related capabilities and extensions are not met
+  // for lower bit-width (<32-bit), convert it to 32-bit
   auto elementType =
       convertScalarType(targetEnv, options, scalarType, storageClass);
   if (elementType)
-    return VectorType::get(type.getShape(), elementType);
-  return nullptr;
+    type = VectorType::get(type.getShape(), elementType);
+  else
+    return nullptr;
+
+  llvm::SmallVector<spirv::Capability, 4> elidedCaps;
+  llvm::SmallVector<spirv::Extension, 4> elidedExts;
+
+  // Relax the bitwidth requirements for capabilities and extensions
+  if (options.emulateLT32BitScalarTypes) {
+    elidedCaps.push_back(spirv::Capability::Int8);
+    elidedCaps.push_back(spirv::Capability::Int16);
+    elidedCaps.push_back(spirv::Capability::Float16);
+  }
+  // For capabilities whose requirements were relaxed, relax requirements for
+  // the extensions that were infered by those capabilities (e.g., elidedCaps)
+  for (auto cap : elidedCaps) {
+    std::optional<::llvm::ArrayRef<::mlir::spirv::Extension>> ext =
+        mlir::spirv::getExtensions(cap);
+    if (ext.has_value())
+      elidedExts.insert(elidedExts.end(), ext.value().begin(),
+                        ext.value().end());
+  }
+  // If all requirements are met, then we can accept this type as-is.
+  if (succeeded(checkCapabilityAndExtensionRequirements(
+          type, targetEnv, capabilities, extensions, elidedCaps, elidedExts)))
+    return type;
+  else {
+    return nullptr;
+  }
 }

 static Type
@@ -1694,16 +1781,18 @@ bool SPIRVConversionTarget::isLegalOp(Operation *op) {
   SmallVector<ArrayRef<spirv::Extension>, 4> typeExtensions;
   SmallVector<ArrayRef<spirv::Capability>, 8> typeCapabilities;
   for (Type valueType : valueTypes) {
-    typeExtensions.clear();
-    cast<spirv::SPIRVType>(valueType).getExtensions(typeExtensions);
-    if (failed(checkExtensionRequirements(op->getName(), this->targetEnv,
-                                          typeExtensions)))
-      return false;
-
     typeCapabilities.clear();
     cast<spirv::SPIRVType>(valueType).getCapabilities(typeCapabilities);
-    if (failed(checkCapabilityRequirements(op->getName(), this->targetEnv,
-                                           typeCapabilities)))
+    typeExtensions.clear();
+    cast<spirv::SPIRVType>(valueType).getExtensions(typeExtensions);
+    // Checking for capability and extension requirements along with capability
+    // infered extensions
+    // If a capability is present, the extension that
+    // supports it should also be present, this reduces the burden of adding
+    // extension requirement that may or maynot be added in
+    // CompositeType::getExtensions()
+    if (failed(checkCapabilityAndExtensionRequirements(
+            op->getName(), this->targetEnv, typeCapabilities, typeExtensions)))
       return false;
   }

--
2.34.1
